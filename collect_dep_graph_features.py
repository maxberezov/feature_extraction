import os
from auxiliary_functions import save_to_cvs, deletion, do_for_all_files_in_directory
from tpips_files_generation import create_tpips_with_dependence_graph, create_tpips_with_gen_multi_recurse
from tpips_files_generation import generate_file_for_all_functions, generate_file_for_all_functions_polybench
from settings import tsvc_benchmark, polybench_benchmark, generated_benchmark
from handcrafted_dependencies import Dependencies
from control_flow import Control_flow


def generation_pipeline(benchmark, function, extension):
    """
    This function generates all necessary tpips files and applies them
    :param benchmark: benchmark object, considering benchmark
    :param extension: string, extension of the files related to graphs after PIPS
    :param function: function, function to apply generation of all tpips files
    """

    deletion(benchmark.dep_graphs, extension)
    deletion(benchmark.cfg_graphs, extension)
    function(benchmark, create_tpips_with_dependence_graph, 'graph', )
    function(benchmark, create_tpips_with_gen_multi_recurse, 'recurse')


def get_bounds_for_polybench_kernel(file):
    index = polybench_benchmark.names.index(file[file.rfind('/') + 14:])
    return polybench_benchmark.bounds[index]


def get_dep_graph_handcrafted_features(path, extension, dependence_object, bounds):
    """
    This function extracts dependence graph handcrafted features +  gets dependence graphs for a given benchmark
    :param path: path, path to dependence graph for a given benchmark
    :param extension: string, extension of those files
    :param dependence_object: object, class - Dependencies
    :param bounds: list, bounds for dependence files for given benchmark
    """
    os.chdir(path)
    files = os.listdir(path)
    for item in files:
        if item.endswith(extension):
            target_path = os.path.join(path, item)
            if bounds:
                dependence_object.feature_extraction_for_a_given_file(target_path,
                                                                      get_bounds_for_polybench_kernel(target_path))
            else:
                dependence_object.feature_extraction_for_a_given_file(target_path)
    dependence_object.add_labels()


def dep_graph_handcrafted_features_extraction(dependence_object, dep_graph_path, extension, output_path, bounds=True):
    """
    This function extracts handcrafted dep graph features and saves them to csv. It returns these features,
    names of corresponding kernels and corresponding dependence graphs
    :param bounds: bool, existence of loop bounds in a generated by PIPS file for loop nests
    :param dependence_object: object, class - Dependencies
    :param dep_graph_path: path, path to the dep graph files generated by PIPS for given benchmark
    :param extension: string, extension of these files
    :param output_path: path, path of the output file with features
    :return: (list,list,list) - 3 lists, first one - with features, 2nd - with names of kernels, 3rd - corresponding graphs
    """
    get_dep_graph_handcrafted_features(dep_graph_path, extension, dependence_object, bounds)
    save_to_cvs(dependence_object.output, output_path)
    return dependence_object.output, dependence_object.names, dependence_object.graphs


def control_flow_graph_extraction(control_flow_object, cfg_graphs_path, extension):
    """
    Tis function returns graphs and corresponding kernels names for files generated by PIPS
    :param control_flow_object: object, class - Control_flow
    :param cfg_graphs_path: path, path to the files generated by PIPS
    :param extension: string, extension of these files
    :return: (list,list), list of graphs and list of their names
    """
    do_for_all_files_in_directory(cfg_graphs_path, extension, control_flow_object.get_timeline_for_a_single_file)
    return control_flow_object.get_control_flow_graphs(control_flow_object.timeline, control_flow_object.kernel_path)


def full_path(benchmark, extension=''):
    """
    This function applies all generation and extraction path of DDG and CFG for considering benchmark
    :param benchmark: benchmark object, considering benchmark
    :param extension: string, extension of the files related to graphs after PIPS
    """
    bounds = lambda: True if benchmark is polybench_benchmark else False
    function = lambda: generate_file_for_all_functions_polybench if benchmark is polybench_benchmark else generate_file_for_all_functions
    generation_pipeline(benchmark, function(), extension)
    dep_graph_handcrafted_features_extraction(Dependencies(), benchmark.dep_graphs, extension,
                                              benchmark.handcrafted_features, bounds())
    control_flow_graph_extraction(Control_flow(), benchmark.cfg_graphs, extension)


def main():
    full_path(generated_benchmark)
    full_path(polybench_benchmark)
    full_path(tsvc_benchmark)



if __name__ == '__main__':
    main()
